<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <title>Title</title>
</head>
<body>
<div style="width: 100%; height: 90vh">
    <div style="width: 100%; height: 50px; float: left;background-color: #3c88ff;"></div>
    <div style="width: 20%; height: calc(100% - 50px); float: left;background-color: rgba(60,136,255,0.59);"></div>
    <div style="width: 80%; height: calc(100% - 50px); float: left;background-color: rgba(60,136,255,0);">
        <canvas id="canvas"></canvas>
    </div>
    <div style="clear: both;"></div>
</div>
</body>
<script type="text/javascript" src="js/jquery-3.4.1.js"></script>
<script type="text/javascript" src="js/fabric-3.6.0.js"></script>
<script type="text/javascript">
    var canvasDraw;
    var nowTool;
    $(function () {
        canvasDraw = CanvasDrawBuilder.createNew('canvas', {
            canvasWidth: $('#canvas').parent()[0].scrollWidth,
            canvasHeight: $('#canvas').parent()[0].scrollHeight,
        });
    });

    //region 画布处理类 极简版
    /** 使用 快捷键: ctrl + 1(鼠标) 2(铅笔) 3(矩形) 4(箭头) 5(文本) 6(椭圆)
     *  var canvasDraw = CanvasDrawBuilder.createNew('canvas', {
            canvasWidth: $('#canvas').parent()[0].scrollWidth,
            canvasHeight: $('#canvas').parent()[0].scrollHeight,
        });
     */
    var CanvasDrawBuilder = {
        //region 静态公共字段
        pointer: 'pointer',
        clear: 'clear',
        pencil: 'pencil',
        rect: 'rect',
        circle: 'circle',
        ellipse: 'ellipse',
        line: 'line',
        dottedLine: 'dottedLine',
        arrow: 'arrow',
        text: 'text',
        undo: 'undo',// 撤回
        redo: 'redo',// 复原
        remove: 'remove',// 删除
        //endregion
        /**
         *
         * @param canvasId 画布ID
         * @param config 配置
         * @param config.canvasWidth 画布宽
         * @param config.canvasHeight 画布高
         * @param config.strokeColor 画笔颜色
         * @param config.strokeWidths 画笔宽度
         * @param config.color 图形边框等颜色
         * @param config.width 图形边框等宽度
         * @param config.fillColor 填充颜色
         * @param config.fontSize 字体大小
         * @param config.fontColor 字体颜色
         * @param config.defaultToolStr 默认工具
         * @param config.dottedLineStrokeDashArray 虚线间隔 [18,3]是每个18个像素，间隔3个像素  后面的参数是间隔数
         */
        createNew: function (canvasId, config) {
            var newObj = {};
            config = config || {};
            //region 私有变量
            newObj.toolConfig = null;
            newObj.canvas = null;
            newObj.redo = null; //撤回 前进用的
            newObj.controlFlag = null;// 主要是用于事件上
            newObj.writingText = null;// 主要是用于事件上
            newObj.nowToolStr = null;// 当前tool工具
            newObj.nowTool = null;// 当前tool的方法
            newObj.enableKeyMap = true;// 开启快捷键
            newObj.defaultToolStr = true;// 默认工具
            //endregion

            //region 初始化区
            newObj.toolConfig = $.extend({
                canvasWidth: 300,   // 画布宽
                canvasHeight: 150,  // 画布高

                strokeColor: 'red', // 画笔颜色
                strokeWidths: 2,    // 画笔宽度

                color: 'red',       // 图形边框等颜色
                width: 2,           // 图形边框等宽度
                fillColor: '',      // 填充颜色

                fontSize: 18,       // 字体大小
                fontColor: 'black', // 字体颜色

                defaultToolStr: 'pencil', // 默认工具

                dottedLineStrokeDashArray: [18, 3],  //[18,3]是每个18个像素，间隔3个像素  后面的参数是间隔数

            }, config);
            $('#' + canvasId).attr('width', newObj.toolConfig.canvasWidth).attr('height', newObj.toolConfig.canvasHeight);

            newObj.nowToolStr = newObj.toolConfig.defaultToolStr;
            newObj.canvas = new fabric.Canvas(canvasId);
            newObj.canvas.on('mouse:up', function (options) {
                // 如果是带有时间 或者没有选择工具 则不管此
                if (options.transform || !newObj.nowTool)
                    return false;
                if (!newObj.canvas._previousPointer)
                    return false;
                var prevXY = newObj.canvas._previousPointer;
                var diffX = options.pointer.x - prevXY.x;
                var diffY = options.pointer.y - prevXY.y;
                newObj.nowTool(options, {
                    x1: prevXY.x,
                    y1: prevXY.y,
                    x2: options.pointer.x,
                    y2: options.pointer.y,
                    top: diffY > 0 ? prevXY.y : options.pointer.y,
                    left: diffX > 0 ? prevXY.x : options.pointer.x,
                    width: diffX > 0 ? diffX : (-diffX),
                    height: diffY > 0 ? diffY : (-diffY),
                });
            });
            newObj.canvas.on('object:moving', function (e) {
                e.target.opacity = 0.3  //你绘画在画布上对象，移动它们的时候，让它们的透明度变成0.5
            });
            newObj.canvas.on('object:added', function () {
                if (!newObj.controlFlag) {
                    newObj.redo = [];  //撤回用的
                }
                newObj.controlFlag = false
            });
            newObj.canvas.on('object:modified', function (e) {
                e.target.opacity = 1
            });

            document.addEventListener("keydown", function (e) {
                if (e.ctrlKey) {
                    if (e.keyCode === 90 && !e.shiftKey) {// ctrl + z
                        newObj.setNowTool(CanvasDrawBuilder.undo);
                    }
                    if ((e.keyCode === 89 && !e.shiftKey) || (e.shiftKey && e.keyCode === 90)) {// ctrl + y || ctrl + shift + z
                        newObj.setNowTool(CanvasDrawBuilder.redo);
                    }
                }
                if (e.metaKey) {// 苹果command 键
                    if (e.keyCode === 90 && !e.shiftKey) {// ctrl + z
                        newObj.setNowTool(CanvasDrawBuilder.undo);
                    }
                    if ((e.keyCode === 89 && !e.shiftKey)|| (e.shiftKey && e.keyCode === 90)) {// ctrl + y || ctrl + shift + z
                        newObj.setNowTool(CanvasDrawBuilder.redo);
                    }
                }
                if (e.keyCode === 8 || e.keyCode === 46) {// backspace
                    newObj.setNowTool(CanvasDrawBuilder.remove);
                }
                if (newObj.writingText && (e.keyCode === 13) && !e.shiftKey) {
                    var text = newObj.writingText.text;
                    if (text == null || text.trim().length === 0) {
                        newObj.writingText.exitEditing();
                        newObj.canvas.remove(newObj.writingText);
                        newObj.writingText = null;
                    } else {
                        newObj.writingText.exitEditing();
                    }
                }
            });

            document.addEventListener("keyup", function (e) {// ctrl + 1(鼠标) 2(铅笔) 3(矩形) 4(箭头) 5(文本) 6(椭圆)

                if (newObj.enableKeyMap && e.altKey) {
                    switch (e.keyCode) {
                        case 49:// 1
                            nowTool = CanvasDrawBuilder.pointer;
                            break;
                        case 50:// 2
                            nowTool = CanvasDrawBuilder.pencil;
                            break;
                        case 51:// 3
                            nowTool = CanvasDrawBuilder.rect;
                            break;
                        case 52:// 4
                            nowTool = CanvasDrawBuilder.arrow;
                            break;
                        case 53:// 5
                            nowTool = CanvasDrawBuilder.text;
                            break;
                        case 54:// 6
                            nowTool = CanvasDrawBuilder.ellipse;
                            break;
                        default:
                            break;
                    }
                    newObj && newObj.setNowTool(nowTool);
                }
            });

            //endregion

            //region 私有方法
            // 选择工具时的初始化方法
            var chooseToolInit = function () {
                newObj.canvas.isDrawingMode = false;            //绘制设为false
                newObj.canvas.selectable = false;       //
                newObj.canvas.selection = false;        // true-可以多选其他团 false-不能(选了这个的话框也不会出现)
                newObj.canvas.skipTargetFind = true;    // true-不能单选其他团 false-可以选择
            };
            var allToolMap = {
                clear: function (options, optionsExtend) {
                    newObj.canvas.clear();        //清空画布
                },

                pointer: function (options, optionsExtend) {
                    newObj.canvas.isDrawingMode = false;            //绘制设为false
                    newObj.canvas.selectable = true;       //
                    newObj.canvas.selection = true;        // true-可以多选其他团 false-不能(选了这个的话框也不会出现)
                    newObj.canvas.skipTargetFind = false;    // true-不能单选其他团 false-可以选择
                },
                pencil: function (options, optionsExtend) {
                    newObj.canvas.isDrawingMode = true;            //绘制设为true
                    newObj.canvas.freeDrawingBrush.color = newObj.toolConfig.strokeColor;   //画笔颜色
                    newObj.canvas.freeDrawingBrush.width = newObj.toolConfig.strokeWidths;  //画笔宽度
                },
                rect: function (options, optionsExtend) {
                    var draw = new fabric.Rect({
                        top: optionsExtend.top,
                        left: optionsExtend.left,
                        width: optionsExtend.width,
                        height: optionsExtend.height,
                        stroke: newObj.toolConfig.color,   //画笔颜色
                        fill: newObj.toolConfig.fillColor,   //填充颜色
                        strokeWidth: newObj.toolConfig.width,   //画笔宽度
                    });
                    newObj.canvas.add(draw);
                    return draw;
                },
                circle: function (options, optionsExtend) {
                    var draw = new fabric.Circle({
                        top: optionsExtend.top,
                        left: optionsExtend.left,
                        radius: Math.min(optionsExtend.width, optionsExtend.height) / 2,
                        stroke: newObj.toolConfig.color,   //画笔颜色
                        fill: newObj.toolConfig.fillColor,   //填充颜色
                        strokeWidth: newObj.toolConfig.width,   //画笔宽度
                    });
                    newObj.canvas.add(draw);
                    return draw;
                },
                ellipse: function (options, optionsExtend) {
                    var draw = new fabric.Ellipse({
                        top: optionsExtend.top,
                        left: optionsExtend.left,
                        rx: optionsExtend.width / 2,
                        ry: optionsExtend.height / 2,
                        stroke: newObj.toolConfig.color,   //画笔颜色
                        fill: newObj.toolConfig.fillColor,   //填充颜色
                        strokeWidth: newObj.toolConfig.width,   //画笔宽度
                        // originX: 'center',    //从X轴中心点绘制
                        // originY: 'center',    //从Y轴中心点绘制
                    });
                    newObj.canvas.add(draw);
                    return draw;
                },
                line: function (options, optionsExtend) {
                    var draw = new fabric.Line([
                        optionsExtend.x1,
                        optionsExtend.y1,
                        optionsExtend.x2,
                        optionsExtend.y2], {
                        //fabric.Line是fabric封装的方法 直接用就好了
                        stroke: newObj.toolConfig.color,   //画笔颜色
                        strokeWidth: newObj.toolConfig.width,   //画笔宽度
                    });
                    newObj.canvas.add(draw);
                    return draw;
                },
                dottedLine: function (options, optionsExtend) {
                    var draw = new fabric.Line([
                        optionsExtend.x1,
                        optionsExtend.y1,
                        optionsExtend.x2,
                        optionsExtend.y2], {
                        //fabric.Line是fabric封装的方法 直接用就好了
                        strokeDashArray: newObj.toolConfig.dottedLineStrokeDashArray,  //[3,3]是每个3个像素，间隔3个像素  后面的参数是间隔数
                        stroke: newObj.toolConfig.color,   //画笔颜色
                        strokeWidth: newObj.toolConfig.width,   //画笔宽度
                    });
                    newObj.canvas.add(draw);
                    return draw;
                },
                arrow: function (options, optionsExtend) {
                    var draw = new fabric.Path(drawArrow(
                        optionsExtend.x1,
                        optionsExtend.y1,
                        optionsExtend.x2,
                        optionsExtend.y2,
                        17.5, 17.5), {
                        stroke: newObj.toolConfig.color,   //画笔颜色
                        fill: newObj.toolConfig.color,   //画笔颜色
                        strokeWidth: newObj.toolConfig.width,   //画笔宽度
                    });

                    newObj.canvas.add(draw);
                    return draw;
                },
                text: function (options, optionsExtend) {
                    var draw = new fabric.Textbox('', {
                        top: optionsExtend.top,
                        left: optionsExtend.left,
                        fill: newObj.toolConfig.fontColor,   //填充颜色

                        width: 150,
                        fontSize: newObj.toolConfig.fontSize,
                        // hasControls: false,
                    });
                    var existsTexts = newObj.canvas._iTextInstances;
                    if (existsTexts) {// 把文本为空的输入框删除了
                        for (var i = 0; i < existsTexts.length; i++) {
                            var obj = existsTexts[i];
                            obj.selected = false;
                            if (obj.isEditing) {
                                obj.exitEditing();
                                return false;
                            }
                            var text = obj.text;
                            if (text == null || text.trim().length === 0) {
                                newObj.canvas.remove(obj);
                                newObj.writingText = null;
                            }
                        }
                    }
                    newObj.canvas.add(draw);
                    newObj.writingText = draw;
                    draw.enterEditing();
                    return draw;
                },
                undo: function () {//撤回
                    if (newObj.canvas._objects.length > 0) {
                        newObj.redo.push(newObj.canvas._objects.pop());
                        newObj.canvas.renderAll();
                    }
                },
                redo: function () {//前进
                    if (newObj.redo.length > 0) {
                        newObj.controlFlag = true;
                        newObj.canvas.add(newObj.redo.pop());
                        newObj.canvas.renderAll();
                    }
                },
                remove: function () {// 删除
                    var activeObjects = newObj.canvas.getActiveObjects();
                    if (activeObjects.length > 0) {
                        for (var i = 0; i < activeObjects.length; i++) {
                            newObj.canvas.remove(activeObjects[i]);
                        }
                    }
                },
            };
            var drawArrow = function (fromX, fromY, toX, toY, theta, headlen) {
                theta = typeof theta !== 'undefined' ? theta : 30
                headlen = typeof theta !== 'undefined' ? headlen : 10
                // 计算各角度和对应的P2,P3坐标
                let angle = Math.atan2(fromY - toY, fromX - toX) * 180 / Math.PI,
                    angle1 = (angle + theta) * Math.PI / 180,
                    angle2 = (angle - theta) * Math.PI / 180,
                    topX = headlen * Math.cos(angle1),
                    topY = headlen * Math.sin(angle1),
                    botX = headlen * Math.cos(angle2),
                    botY = headlen * Math.sin(angle2)
                let arrowX = fromX - topX,
                    arrowY = fromY - topY;
                let path = ' M ' + fromX + ' ' + fromY;
                path += ' L ' + toX + ' ' + toY;
                arrowX = toX + topX;
                arrowY = toY + topY;
                path += ' M ' + arrowX + ' ' + arrowY;
                path += ' L ' + toX + ' ' + toY;
                arrowX = toX + botX;
                arrowY = toY + botY;
                path += ' L ' + arrowX + ' ' + arrowY;
                return path
            }
            //endregion

            //region 公有字段
            //endregion

            //region 公有方法
            newObj.isEnableKeyMap = function () {
                return newObj.enableKeyMap;
            };
            newObj.setEnableKeyMap = function (enableKeyMap) {
                newObj.enableKeyMap = enableKeyMap;
                return newObj.enableKeyMap;
            };
            newObj.getNowTool = function () {
                return newObj.nowTool;
            };
            newObj.setNowTool = function (toolStr) {
                newObj.nowToolStr = toolStr;
                var thisToolFunc = allToolMap[toolStr];
                switch (toolStr) {
                    case CanvasDrawBuilder.pointer:
                    case CanvasDrawBuilder.pencil:
                        newObj.nowTool = null;
                    case CanvasDrawBuilder.clear:
                    case CanvasDrawBuilder.remove:
                    case CanvasDrawBuilder.undo:
                    case CanvasDrawBuilder.redo:
                        thisToolFunc();
                        break;
                    default:
                        chooseToolInit();
                        newObj.nowTool = thisToolFunc;
                        break;
                }
                newObj.canvas.renderAll();    //重新渲染
                return toolStr;
            };
            //endregion

            newObj.setNowTool(newObj.nowToolStr);
            return newObj;
        }
    };
    //endregion
</script>
</html>